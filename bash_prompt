. ./.bash_colors

function git_prompt_command() {
  # Note that the pattern is actually (e.g.) "## master...origin/master [ahead 1]"
  branch_pattern="^## ([^${IFS}]*)"

  git_status="$(git -c color.status=false status --short --branch 2> /dev/null)"
  if [[ $? != 0 ]] ; then
    return
  fi

  # Figure out which branch we're on.
  if [[ ${git_status} =~ ${branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  fi

  # Parse the file details.
  # Each line is "XY filename", where X denotes the index status, and Y the working status.
  # TODO: It also allows for renames, but I'm not going to bother with those yet.
  file_pattern="^([^#])(.) (.*)$"
  
  dirty=0
  while IFS= read -r line; do
    if [[ $line =~ $file_pattern ]]; then
      dirty=1
    fi
  done <<< "$git_status"

  if [[ $dirty == 0 ]]; then
    echo -n " ${IBlue}(${branch})"
  else
    echo -n " ${IRed}(${branch})"
  fi
                                                          
  echo -n "${Color_Off}"
}

function prompt_command() {
  git_prompt="$(git_prompt_command)"

  PS1="${debian_chroot:+($debian_chroot)}"
  PS1+="${IYellow}\u@\h${ICyan}:\w${git_prompt}${ICyan}\$ $Color_Off"

  # Also update the terminal title bar.
  Title="${debian_chroot:+($debian_chroot)}"
  Title+="\u@\h:\w"

  case "$TERM" in
    xterm*|rxvt*)
    PS1="\[\e]0;$Title\a\]$PS1"
    ;;
  *)
    ;;
  esac

  export PS1
}

export PROMPT_COMMAND=prompt_command

# vim: syntax=sh
