DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
. $DIR/.bash_colors

PromptColor_Git="$IWhite"
PromptColor_BranchAhead="$IGreen"
PromptColor_BranchBehind="$IRed"
PromptColor_BranchBoth="$IYellow"
PromptColor_BranchNeither="$IBlue"
PromptColor_IndexStats="$IGreen"
PromptColor_WorkingStats="$IRed"
PromptColor_UserAtHost="$IYellow"
PromptColor_WorkingDir="$ICyan"
PromptColor_Dollar="$ICyan"

if [[ $UID == 0 ]]; then
  PromptColor_UserAtHost="$IRed"
  PromptColor_WorkingDir="$IYellow"
  PromptColor_Dollar="$IRed"
fi

function git_prompt_command() {
  git_status="$(git -c color.status=false status --short --branch 2> /dev/null)"
  if [[ $? != 0 ]] ; then
    return
  fi

  # Note that the pattern is actually (e.g.) "## master...origin/master [ahead 1]"
  initial_branch_pattern="^## Initial commit on ([^${IFS}]*)"
  normal_branch_pattern="^## ([^${IFS}]*)"
  ahead_branch_pattern="^## (.*)\.\.\.([^${IFS}]*) \[ahead (.*)\]"
  behind_branch_pattern="^## (.*)\.\.\.([^${IFS}]*) \[behind (.*)\]"
  ahead_behind_branch_pattern="^## (.*)\.\.\.([^${IFS}]*) \[ahead (.*), behind (.*)\]"
 
  ahead=0
  behind=0
 
  if [[ ${git_status} =~ ${normal_branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  fi
  if [[ ${git_status} =~ ${initial_branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  fi
  if [[ ${git_status} =~ ${ahead_branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
    ahead=${BASH_REMATCH[3]}
  fi  
  if [[ ${git_status} =~ ${behind_branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
    behind=${BASH_REMATCH[3]}
  fi
  if [[ ${git_status} =~ ${ahead_behind_branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
    ahead=${BASH_REMATCH[3]}
    behind=${BASH_REMATCH[4]}
  fi

  # Parse the file details.
  # Each line is "XY filename", where X denotes the index status, and Y the working status.
  # TODO: It also allows for renames, but I'm not going to bother with those yet.
  file_pattern="^([^#])(.) (.*)$"
  
  dirty=0

  index_added=()
  index_modified=()
  index_deleted=()
  index_unmerged=()

  working_unknown=()
  working_added=()
  working_modified=()
  working_deleted=()
  working_unmerged=()

  while IFS= read -r line; do
    if [[ $line =~ $file_pattern ]]; then
      # Extract the matches.
      index_status=${BASH_REMATCH[1]}
      working_status=${BASH_REMATCH[2]}
      file_path=${BASH_REMATCH[3]}

      case $index_status in
        A) index_added+=(file_path) ;;
        M) index_modified+=(file_path) ;;
        R) index_modified+=(file_path) ;;
        C) index_modified+=(file_path) ;;
        D) index_deleted+=(file_path) ;;
        U) index_unmerged+=(file_path) ;;
        *) ;;
      esac

      case $working_status in
        \?) working_unknown+=(file_path) ;;
        A) working_added+=(file_path) ;;
        M) working_modified+=(file_path) ;;
        D) working_deleted+=(file_path) ;;
        U) working_unmerged+=(file_path) ;;
        *) ;;
      esac

      dirty=1
    fi
  done <<< "$git_status"

  echo -n " ${PromptColor_Git}["

  # The colour should be based on whether we're ahead of or behind the remote.
  if [[ $ahead != 0 && $behind != 0 ]]; then
    echo -n "${PromptColor_BranchBoth}"
  elif [[ $ahead != 0 ]]; then
    echo -n "${PromptColor_BranchAhead}"
  elif [[ $behind != 0 ]]; then
    echo -n "${PromptColor_BranchBehind}"
  else
    echo -n "${PromptColor_BranchNeither}"
  fi

  echo -n "${branch}"

  # Display index stats:
  echo -n "${PromptColor_IndexStats}"
  if [[ ${#index_added[*]} != 0 ]]; then
    echo -n " +${#index_added[*]}"
  fi
  
  if [[ ${#index_modified[*]} != 0 ]]; then
    echo -n " ~${#index_modified[*]}"
  fi
  if [[ ${#index_deleted[*]} != 0 ]]; then
    echo -n " -${#index_deleted[*]}"
  fi
  if [[ ${#index_unmerged[*]} != 0 ]]; then
    echo -n " !${#index_unmerged[*]}"
  fi

  # Display working stats:
  echo -n "${PromptColor_WorkingStats}"
  if [[ ${#working_unknown[*]} != 0 ]]; then
    echo -n " ?${#working_unknown[*]}"
  fi
  if [[ ${#working_added[*]} != 0 ]]; then
    echo -n " +${#working_added[*]}"
  fi
  if [[ ${#working_modified[*]} != 0 ]]; then
    echo -n " ~${#working_modified[*]}"
  fi
  if [[ ${#working_deleted[*]} != 0 ]]; then
    echo -n " -${#working_deleted[*]}"
  fi
  if [[ ${#working_unmerged[*]} != 0 ]]; then
    echo -n " !${#working_unmerged[*]}"
  fi

  echo -n "${PromptColor_Git}] "
  echo -n "${Color_Off}"
}

function prompt_command() {
  git_prompt="$(git_prompt_command)"

  # debian_chroot stuff.
  PS1="${debian_chroot:+($debian_chroot)}"
  # roger@host:~/cwd
  PS1+="${PromptColor_UserAtHost}\u@\h${PromptColor_WorkingDir}:\w"
  # [git stuff]
  PS1+="${git_prompt}"
  # $ suffix.
  PS1+="${PromptColor_Dollar}\\$"
  PS1+="$Color_Off"
  PS1+=" "

  # Also update the terminal title bar.
  Title="${debian_chroot:+($debian_chroot)}"
  Title+="\u@\h:\w"

  case "$TERM" in
    xterm*|rxvt*)
    PS1="\[\e]0;$Title\a\]$PS1"
    ;;
  *)
    ;;
  esac

  export PS1
}

export PROMPT_COMMAND=prompt_command

# vim:set syntax=sh:set filetype=sh
