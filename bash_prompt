. ./.bash_colors

function git_status_is_dirty() {
  git_status="$1"

  printf %s "${git_status}" |
  while IFS= read -r line; do
    if [[ ${line} =~ ${file_pattern} ]]; then
      index_status=${BASH_REMATCH[1]}
      working_status=${BASH_REMATCH[2]}
                      
      # We came through here somehow, so there must be changes.
      echo 1
    fi
  done
}

function git_prompt_command() {
  # Note that the pattern is actually (e.g.) "## master...origin/master [ahead 1]"
  branch_pattern="^## ([^${IFS}]*)"

  git_status="$(git -c color.status=false status --short --branch 2> /dev/null)"
  if [[ $? != 0 ]] ; then
    return
  fi

  # Figure out which branch we're on.
  if [[ ${git_status} =~ ${branch_pattern} ]]; then
    branch=${BASH_REMATCH[1]}
  fi

  # Parse the file details.
  # Each line is "XY filename", where X denotes the index status, and Y the working status.
  # TODO: It also allows for renames, but I'm not going to bother with those yet.
  file_pattern="^([^#])(.) (.*)$"

#  dirty=git_status_is_dirty "$git_status"
#  echo -n $dirty

  # Actually do something interesting with these numbers.
#  if [[ -z $dirty ]]; then
#    echo -n " ${IRed}(${branch})"
#  else
    echo -n " ${IBlue}(${branch})"
#  fi
                                                          
  echo -n "${Color_Off}"
}

function prompt_command() {
  git_prompt="$(git_prompt_command)"

  PS1="${debian_chroot:+($debian_chroot)}"
  PS1+="${IYellow}\u@\h${ICyan}:\w${git_prompt}${ICyan}\$ $Color_Off"

  # Also update the terminal title bar.
  Title="${debian_chroot:+($debian_chroot)}"
  Title+="\u@\h:\w"

  case "$TERM" in
    xterm*|rxvt*)
    PS1="\[\e]0;$Title\a\]$PS1"
    ;;
  *)
    ;;
  esac

  export PS1
}

export PROMPT_COMMAND=prompt_command

# vim: syntax=sh
